/* This file contains functions relating to creating and comparing trace and target (user-given) graphs */

use petgraph::graph::{Graph, NodeIndex};
use petgraph::algo::{toposort, dijkstra};
use std::collections::HashMap;


/* This function creates a petgraph graph representing the query given by the user.
 * For example, if the cql query were MATCH n -> m, e WHERE ... the input to this function
 * would be vertices = [n, m], edges = [(n,m)].
 *
 * Arguments:
 * @vertices:  the vertices of the graph to construct
 * @edges:  the edges of the graph to construct
 *
 * Return Value:
 * @graph: the constructed graph reprsenting the inputs
 */

pub fn generate_target_graph(vertices: Vec<String>,
                            edges: Vec<(String, String)>,
                            _ids_to_properties: HashMap<String, Vec<String>>)
                           -> Graph<String, String> {
    let mut graph = Graph::new();

    // In order to make edges, we have to know the handles of the nodes, and you 
    // get the handles of the nodes by adding them to the graph

    let mut nodes_to_node_handles: HashMap<String, NodeIndex> = HashMap::new();
    for node in vertices {
        nodes_to_node_handles.insert(node.clone(), graph.add_node(node.clone()));
    }

    // Make edges with handles instead of the vertex names
    let mut edge_handles = Vec::new();
    for edge in edges {
        let node0 = nodes_to_node_handles[&edge.0];
        let node1 = nodes_to_node_handles[&edge.1];
        let new_edge = (node0, node1);
        edge_handles.push(new_edge);
    }
    graph.extend_with_edges(edge_handles);

    graph
}


/*  This function creates a petgraph graph representing a single trace.
 *  The trace is represented in paths_header as a string where the first node is 
 *  the root.  Thus "0 1 2" is a graph that looks like 0 -> 1 -> 2 with 0 as root.
 *
 *  Arguments:
 *  @paths_header:  the string version of the trace, generated by the tracing simulator
 *
 *  Return Value:
 *  @graph:  A petgraph graph representation of the same trace
 */
pub fn generate_trace_graph_from_headers(paths_header: String) -> Graph<String, String> {
    let mut graph = Graph::new();
    let mut nodes_iterator = paths_header.split_whitespace();
    let mut node_str_to_node_handle = HashMap::new();
    let first_node = nodes_iterator.next();
    if first_node.is_none() {
        return graph; // clearly we don't have anything, so return an empty graph
    }
    let first_node_str = first_node.unwrap();
    node_str_to_node_handle.insert(first_node_str.to_string(), graph.add_node(first_node_str.to_string()));
    let mut prev_node_handle = node_str_to_node_handle[first_node_str];
    for node_str in nodes_iterator {
        // 1. Is this node already in the graph?  If so, ignore it and move "up" the tree
        if !node_str_to_node_handle.contains_key(node_str) {
            let new_node_handle = graph.add_node(node_str.to_string());
            node_str_to_node_handle.insert(node_str.to_string(), new_node_handle);
            graph.add_edge(prev_node_handle, new_node_handle, "".to_string());
            prev_node_handle = new_node_handle;
        }
        else {
            prev_node_handle = node_str_to_node_handle[node_str];
        }
    }
    graph
}

pub fn get_node_with_id(graph: &Graph<String, String>, node_name: String) -> Option<NodeIndex> {
    for index in graph.node_indices() {
        if graph.node_weight(index).unwrap() == &node_name {
            return Some(index);
        }
    }
    None
}

pub fn get_tree_height(graph: &Graph<String, String>, root: Option<NodeIndex>) -> u32 {
    let starting_point;
    if !root.is_none() { starting_point = root.unwrap() }
    else {
        // The root of the tree by definition has no incoming edges
        let sorted = toposort(graph, None).unwrap();
        starting_point = sorted[0];
    }
    let node_map = dijkstra(graph, starting_point, None, |_| 1);
    let mut max = 0;
    for key in node_map.keys() {
        if node_map[key] > max {
            max = node_map[key];
        }
    }
    return max;
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_small_trace_graph() -> Graph<String, String> {
        let graph_string = String::from("0 1 2");
        let graph = generate_trace_graph_from_headers(graph_string);
        graph
    }


    fn make_small_target_graph() -> Graph<String, String> {
        let a = String::from("a");
        let b = String::from("b");
        let c = String::from("c");
        let vertices = vec![ a.clone(), b.clone(), c.clone()];
        let edges = vec![(a.clone(), b.clone()), (b.clone(), c.clone())];
        let mut ids_to_properties = HashMap::new();
        for vertex in vertices.clone() {
            ids_to_properties.insert(vertex.clone(), Vec::new());
        }
        let graph = generate_target_graph(vertices, edges, ids_to_properties);
        graph
    }

    #[test]
    fn test_generate_trace_graph_from_headers_non_branching_graph() {
        let graph = make_small_trace_graph();
        assert_eq!(graph.node_count(), 3);
        assert_eq!(graph.edge_count(), 2);
    }

    #[test]
    fn test_generate_target_graph() {
        let graph = make_small_target_graph();
        assert_eq!(graph.node_count(), 3);
        assert_eq!(graph.edge_count(), 2);
    }


    #[test]
    fn test_correctly_parse_branching_graphs() {
        let graph = generate_trace_graph_from_headers("0 1 3 1 2".to_string());
        assert!(graph.node_count()==4);
        for node in graph.node_indices() {
            if graph.node_weight(node).unwrap() == "0" {
                assert!(graph.neighbors(node).count() == 1);
            }
            if graph.node_weight(node).unwrap() == "1" {
                assert!(graph.neighbors(node).count() == 2);
            }
        }

    }

    #[test]
    fn test_generate_trace_graph_from_headers_on_empty_string() {
        let graph = generate_trace_graph_from_headers(String::new());
        assert!(graph.node_count()==0);
    }
    #[test]
    fn test_get_tree_height() {
        let graph = generate_trace_graph_from_headers("0 1 3 1 2".to_string());
        assert!(get_tree_height(&graph, None)==2);
    }

}
